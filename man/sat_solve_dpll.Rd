% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solver-dpll.R
\name{sat_solve_dpll}
\alias{sat_solve_dpll}
\title{SAT solver using DPLL technique}
\usage{
sat_solve_dpll(sat, max_solutions = 1, remove = "^dummy", verbosity = 0L)
}
\arguments{
\item{sat}{SAT problem as created by \code{\link{sat_new}()}}

\item{max_solutions}{maximum number of solutions to return. Default: 1}

\item{remove}{regular expression for variables to remove when blocking solutions
and assembling values to return. Default: "^dummy" will block all
variables starting with the word "dummy" (as this is how the 'satire' 
package automatically creates dummy variables.)
If NULL no variables will be removed.}

\item{verbosity}{verbosity level.  Default: 0}
}
\value{
data.frame of logical values. Columns correspond to the variable 
        names within the problem.  Each row defines a solution.
}
\description{
This pure R recursive solver uses DPLL methods (unit propagation and pure literal
elimination).  This solver works recursively and can be used to solve 
problems with 10s to 100s of variables.  However, as all the code is
in R, this is not as fast as using a compiled solver.
}
\details{
For larger problems >100 variables, it may better to export the problem
as a DIMACS file and solve externally.
}
\examples{
sat <- sat_new()
sat_card_atmost_k(sat, letters[1:4], 3)
sat$exprs
sat$names
sat_solve_naive(sat)
sat_solve_dpll(sat, max_solutions = 20)
}
\seealso{
Other SAT solvers: 
\code{\link{sat_solve_naive}()}
}
\concept{SAT solvers}
