% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solver-dpll.R
\name{sat_solve_dpll}
\alias{sat_solve_dpll}
\title{SAT solver using DPLL technique}
\usage{
sat_solve_dpll(sat, max_solutions = 1, remove_dummy = TRUE, verbosity = 0L)
}
\arguments{
\item{sat}{SAT problem as created by \code{\link{sat_new}()}}

\item{max_solutions}{maximum number of solutions to return. Default: 1}

\item{remove_dummy}{Remove dummy variables from result. Default: TRUE. Dummy 
variables are used in many places (e.g. cardinality constraints). These 
variables are not part of the user's problem statement, and most 
of the time should not be present in the solution.  A variable is
considered a dummy variable if it starts with the word "dummy".}

\item{verbosity}{verbosity level.  Default: 0}
}
\value{
data.frame of logical values. Columns correspond to the variable 
        names within the problem.  Each row defines a solution.
}
\description{
This pure R recursive solver uses DPLL methods (unit propagation and pure literal
elimination).  This solver works recursively and can be used to solve 
problems with 10s to 100s of variables.  However, as all the code is
in R, this is not as fast as using a compiled solver.
}
\details{
For larger problems >100 variables, it may better to export the problem
as a DIMACS file and solve externally.
}
\examples{
sat <- sat_new()
sat_card_atmost_k(sat, letters[1:4], 3)
sat$exprs
sat$names
sat_solve_naive(sat)
sat_solve_dpll(sat, max_solutions = 20)
}
\seealso{
Other SAT solvers: 
\code{\link{sat_solve_naive}()}
}
\concept{SAT solvers}
